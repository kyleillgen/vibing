<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Monkey Fly-Squash Game</title>
  <!-- Load p5.js from the official CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
          crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <script>
    // Central script: all game logic lives here for GitHub Pages
    console.log('Vibing: code running on GitHub!');

    let flies = [];
    let score = 0;
    let isClapping = false;

    let handX = 250;
    let handY = 250;
    const DEFAULT_HAND_SPEED = 4;
    let handSpeed = DEFAULT_HAND_SPEED;

    let squashes = [];

    const POWER_UP_RADIUS = 20;
    const SPAWN_INTERVAL = 30000; // ms
    const POWER_UPS = [
      { rank: 1, name: "Score Frenzy", effect: "+5x score per fly", tier: "Legendary", color: "#FFD700", duration: 45, rarity: 0.5 },
      { rank: 2, name: "Time Freeze", effect: "Freezes flies in place", tier: "Legendary", color: "#FFD700", duration: 35, rarity: 1 },
      { rank: 3, name: "Clap Magnet", effect: "Clap range doubled", tier: "Epic", color: "#A335EE", duration: 30, rarity: 2.5 },
      { rank: 4, name: "Quick Hands", effect: "Hand speed +50%", tier: "Uncommon", color: "#1EFF00", duration: 30, rarity: 7 }
    ];

    let spawnPowerUp = null;
    let activePowerUp = null;
    let activeEndsAt = 0;
    let nextPowerUpTime = 0;
    const DEFAULT_SCORE_MULTIPLIER = 1;
    let scoreMultiplier = DEFAULT_SCORE_MULTIPLIER;
    const DEFAULT_CLAP_RADIUS = 30;
    let clapRadius = DEFAULT_CLAP_RADIUS;
    let fliesFrozen = false;

    function setup() {
      createCanvas(500, 500);
      textAlign(CENTER, CENTER);
      angleMode(DEGREES);

      for (let i = 0; i < 5; i++) {
        flies.push(createFly());
      }
      nextPowerUpTime = millis() + SPAWN_INTERVAL;
    }

    function draw() {
      background(255, 239, 200);
      // Reset text alignment each frame so subsequent drawing routines
      // start from a predictable state.
      textAlign(CENTER, CENTER);
      handleKeys();

      drawMonkey();

      for (let i = flies.length - 1; i >= 0; i--) {
        moveFly(flies[i]);
        drawFly(flies[i]);

        if (isClapping && flyInClapZone(flies[i])) {
          squashes.push({
            x: flies[i].x,
            y: flies[i].y,
            timestamp: millis()
          });

          score += Math.floor(10 * scoreMultiplier);
          flies.splice(i, 1);
          flies.push(createFlyFromEdge());
        } else if (flyEscaped(flies[i])) {
          flies.splice(i, 1);
          flies.push(createFlyFromEdge());
        }
      }

      drawHands();
      drawSquashes();
      updatePowerUps();

      // Score
      fill(0);
      textSize(20);
      textAlign(RIGHT, TOP);
      text("Score: " + score, width - 10, 10);
    }

    function drawMonkey() {
      const centerX = width / 2;
      const centerY = height / 2;

      fill(160, 82, 45);
      ellipse(centerX, centerY, 200, 200);

      fill(0);
      ellipse(centerX - 30, centerY - 20, 20, 20);
      ellipse(centerX + 30, centerY - 20, 20, 20);

      noFill();
      stroke(0);
      strokeWeight(3);
      arc(centerX, centerY + 30, 60, 30, 0, PI);
    }

    function drawHands() {
      const centerX = width / 2;
      const centerY = height / 2;

      noStroke();
      fill(160, 82, 45);

      if (isClapping) {
        ellipse(handX, handY, 40, 40);
        ellipse(handX, handY, 40, 40); // both at same position
        fill(255, 0, 0);
        textSize(24);
        text("üëè", handX, handY - 40);
      } else {
        // Show hands apart (symmetric around monkey center)
        let dx = handX - centerX;
        let dy = handY - centerY;

        ellipse(centerX + dx, centerY + dy, 30, 30); // right hand
        ellipse(centerX - dx, centerY - dy, 30, 30); // left hand
      }
    }

    function handleKeys() {
      if (keyIsDown(LEFT_ARROW)) handX -= handSpeed;
      if (keyIsDown(RIGHT_ARROW)) handX += handSpeed;
      if (keyIsDown(UP_ARROW)) handY -= handSpeed;
      if (keyIsDown(DOWN_ARROW)) handY += handSpeed;

      handX = constrain(handX, 0, width);
      handY = constrain(handY, 0, height);

      isClapping = keyIsDown(65); // 'A'
    }

    function createFly() {
      return {
        x: random(width),
        y: random(height),
        size: 12,
        dx: random([-1, 1]) * random(2, 4),
        dy: random([-1, 1]) * random(2, 4),
        bounce: random() < 0.5
      };
    }

    function createFlyFromEdge() {
      let edge = floor(random(4));
      let fly = createFly();

      switch (edge) {
        case 0: fly.x = random(width); fly.y = 0; break;
        case 1: fly.x = width; fly.y = random(height); break;
        case 2: fly.x = random(width); fly.y = height; break;
        case 3: fly.x = 0; fly.y = random(height); break;
      }

      return fly;
    }

    function moveFly(fly) {
      if (fliesFrozen) return;

      fly.x += fly.dx;
      fly.y += fly.dy;

      if (fly.bounce) {
        if (fly.x < 0 || fly.x > width) fly.dx *= -1;
        if (fly.y < 0 || fly.y > height) fly.dy *= -1;
      }
    }

    function flyEscaped(fly) {
      return !fly.bounce && (fly.x < -20 || fly.x > width + 20 || fly.y < -20 || fly.y > height + 20);
    }

    function drawFly(fly) {
      fill(50);
      ellipse(fly.x, fly.y, fly.size);
    }

    function flyInClapZone(fly) {
      return dist(fly.x, fly.y, handX, handY) < clapRadius;
    }

    function drawSquashes() {
      let now = millis();
      for (let i = squashes.length - 1; i >= 0; i--) {
        let s = squashes[i];
        if (now - s.timestamp < 1000) {
          fill(255, 0, 0);
          textSize(20);
          text("üí• SQUASH!", s.x, s.y);
        } else {
          squashes.splice(i, 1);
        }
      }
    }

    function updatePowerUps() {
      const now = millis();

      if (activePowerUp && now > activeEndsAt) {
        clearPowerUpEffects();
        activePowerUp = null;
        nextPowerUpTime = now + SPAWN_INTERVAL;
      }

      if (!spawnPowerUp && !activePowerUp && now > nextPowerUpTime) {
        spawnPowerUp = createPowerUp();
      }

      if (spawnPowerUp) {
        noStroke();
        fill(spawnPowerUp.color);
        ellipse(spawnPowerUp.x, spawnPowerUp.y, POWER_UP_RADIUS * 2);
        if (isClapping && dist(spawnPowerUp.x, spawnPowerUp.y, handX, handY) < POWER_UP_RADIUS + 10) {
          activePowerUp = spawnPowerUp;
          activeEndsAt = now + Math.min(activePowerUp.duration, 5) * 1000;
          applyPowerUp(activePowerUp);
          spawnPowerUp = null;
        }
      }

      if (activePowerUp) {
        const remaining = Math.max(0, activeEndsAt - now);
        fill(0);
        textAlign(CENTER, TOP);
        textSize(16);
        // Display whole seconds remaining for the active power-up.
        text(
          "Power-Up: " +
            activePowerUp.name +
            " (" + Math.ceil(remaining / 1000) + "s)",
          width / 2,
          10
        );
      }
    }

    function createPowerUp() {
      const weights = POWER_UPS.map(p => p.rarity);
      const total = weights.reduce((a, b) => a + b, 0);
      let r = random(total);
      let cumulative = 0;
      for (let i = 0; i < POWER_UPS.length; i++) {
        cumulative += weights[i];
        if (r < cumulative) {
          return { ...POWER_UPS[i], x: random(width), y: random(height) };
        }
      }
      return null;
    }

    function clearPowerUpEffects() {
      scoreMultiplier = DEFAULT_SCORE_MULTIPLIER;
      handSpeed = DEFAULT_HAND_SPEED;
      clapRadius = DEFAULT_CLAP_RADIUS;
      fliesFrozen = false;
    }

    function applyPowerUp(powerUp) {
      clearPowerUpEffects();
      switch (powerUp.name) {
        case "Score Frenzy":
          scoreMultiplier = 5;
          break;
        case "Time Freeze":
          fliesFrozen = true;
          break;
        case "Clap Magnet":
          clapRadius = DEFAULT_CLAP_RADIUS * 2;
          break;
        case "Quick Hands":
          handSpeed = DEFAULT_HAND_SPEED * 1.5;
          break;
      }
    }
  </script>
</body>
</html>
