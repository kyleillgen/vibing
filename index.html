<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Monkey Fly-Squash Game</title>
  <!-- Load p5.js from the official CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
          crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <script>
    // Central script: all game logic lives here for GitHub Pages
    console.log('Vibing: code running on GitHub!');

    let flies = [];
    let score = 0;
    let isClapping = false;

    let handX = 250;
    let handY = 250;
    let handSpeed = 4;

    let squashes = [];

    const POWER_UP_RADIUS = 20;
    const SPAWN_INTERVAL = 30000; // ms

    const POWER_UP_DEFS = [
      ["Mega Multiplier", "Multiply all points by five."],
      ["Golden Banana", "Each hit grants a massive score bonus."],
      ["Combo Frenzy", "Combo meter builds twice as fast."],
      ["Fever Time", "Triple points for every beat."],
      ["Perfect Shield", "Misses do not break your combo."],
      ["Tempo Boost", "Slightly faster tempo for more scoring chances."],
      ["Time Warp", "Slows beat scroll speed."],
      ["Streak Saver", "Automatically saves the next missed beat."],
      ["Banana Magnet", "Nearby bananas fly toward you."],
      ["Score Burst", "Periodic bursts of bonus points."],
      ["Groove Guard", "Blocks the next obstacle."],
      ["Beat Freeze", "Freezes beats briefly on activation."],
      ["Drum Echo", "Each hit echoes for an extra score tick."],
      ["Banana Bloom", "Spawns extra bananas to catch."],
      ["Rhythm Rush", "More beats spawn for a short time."],
      ["Monkey March", "Auto-hits basic beats."],
      ["Tap Booster", "Temporarily enlarges the hit box."],
      ["Beat Bonus", "Adds a small bonus to every beat."],
      ["Banana Trick", "Random small bonus each hit."],
      ["Happy Hour", "Slight constant score buff."]
    ];

    function tierForRank(rank) {
      if (rank <= 3) return { tier: "Legendary", color: "#FF8000", duration: 45 };
      if (rank <= 7) return { tier: "Epic", color: "#A335EE", duration: 35 };
      if (rank <= 12) return { tier: "Rare", color: "#0070FF", duration: 30 };
      if (rank <= 16) return { tier: "Uncommon", color: "#1EFF00", duration: 25 };
      return { tier: "Common", color: "#BEBEBE", duration: 20 };
    }

    const POWER_UPS = POWER_UP_DEFS.map(([name, effect], i) => {
      const rank = i + 1;
      const { tier, color, duration } = tierForRank(rank);
      return { name, effect, rank, tier, color, duration };
    });

    let spawnPowerUp = null;
    let activePowerUp = null;
    let activeEndsAt = 0;
    let nextPowerUpTime = 0;
    let scoreMultiplier = 1;

    function setup() {
      createCanvas(500, 500);
      textAlign(CENTER, CENTER);
      angleMode(DEGREES);

      for (let i = 0; i < 5; i++) {
        flies.push(createFly());
      }
      nextPowerUpTime = millis() + SPAWN_INTERVAL;
    }

    function draw() {
      background(255, 239, 200);
      handleKeys();

      drawMonkey();

      for (let i = flies.length - 1; i >= 0; i--) {
        moveFly(flies[i]);
        drawFly(flies[i]);

        if (isClapping && flyInClapZone(flies[i])) {
          squashes.push({
            x: flies[i].x,
            y: flies[i].y,
            timestamp: millis()
          });

          score += Math.floor(10 * scoreMultiplier);
          flies.splice(i, 1);
          flies.push(createFlyFromEdge());
        } else if (flyEscaped(flies[i])) {
          flies.splice(i, 1);
          flies.push(createFlyFromEdge());
        }
      }

      drawHands();
      drawSquashes();
      updatePowerUps();

      // Score
      fill(0);
      textSize(20);
      textAlign(RIGHT, TOP);
      text("Score: " + score, width - 10, 10);
    }

    function drawMonkey() {
      const centerX = width / 2;
      const centerY = height / 2;

      fill(160, 82, 45);
      ellipse(centerX, centerY, 200, 200);

      fill(0);
      ellipse(centerX - 30, centerY - 20, 20, 20);
      ellipse(centerX + 30, centerY - 20, 20, 20);

      noFill();
      stroke(0);
      strokeWeight(3);
      arc(centerX, centerY + 30, 60, 30, 0, PI);
    }

    function drawHands() {
      const centerX = width / 2;
      const centerY = height / 2;

      noStroke();
      fill(160, 82, 45);

      if (isClapping) {
        ellipse(handX, handY, 40, 40);
        ellipse(handX, handY, 40, 40); // both at same position
        fill(255, 0, 0);
        textSize(24);
        text("üëè", handX, handY - 40);
      } else {
        // Show hands apart (symmetric around monkey center)
        let dx = handX - centerX;
        let dy = handY - centerY;

        ellipse(centerX + dx, centerY + dy, 30, 30); // right hand
        ellipse(centerX - dx, centerY - dy, 30, 30); // left hand
      }
    }

    function handleKeys() {
      if (keyIsDown(LEFT_ARROW)) handX -= handSpeed;
      if (keyIsDown(RIGHT_ARROW)) handX += handSpeed;
      if (keyIsDown(UP_ARROW)) handY -= handSpeed;
      if (keyIsDown(DOWN_ARROW)) handY += handSpeed;

      handX = constrain(handX, 0, width);
      handY = constrain(handY, 0, height);

      isClapping = keyIsDown(65); // 'A'
    }

    function createFly() {
      return {
        x: random(width),
        y: random(height),
        size: 12,
        dx: random([-1, 1]) * random(2, 4),
        dy: random([-1, 1]) * random(2, 4),
        bounce: random() < 0.5
      };
    }

    function createFlyFromEdge() {
      let edge = floor(random(4));
      let fly = createFly();

      switch (edge) {
        case 0: fly.x = random(width); fly.y = 0; break;
        case 1: fly.x = width; fly.y = random(height); break;
        case 2: fly.x = random(width); fly.y = height; break;
        case 3: fly.x = 0; fly.y = random(height); break;
      }

      return fly;
    }

    function moveFly(fly) {
      fly.x += fly.dx;
      fly.y += fly.dy;

      if (fly.bounce) {
        if (fly.x < 0 || fly.x > width) fly.dx *= -1;
        if (fly.y < 0 || fly.y > height) fly.dy *= -1;
      }
    }

    function flyEscaped(fly) {
      return !fly.bounce && (fly.x < -20 || fly.x > width + 20 || fly.y < -20 || fly.y > height + 20);
    }

    function drawFly(fly) {
      fill(50);
      ellipse(fly.x, fly.y, fly.size);
    }

    function flyInClapZone(fly) {
      return dist(fly.x, fly.y, handX, handY) < 30;
    }

      function drawSquashes() {
        let now = millis();
        for (let i = squashes.length - 1; i >= 0; i--) {
          let s = squashes[i];
          if (now - s.timestamp < 1000) {
            fill(255, 0, 0);
            textSize(20);
            text("üí• SQUASH!", s.x, s.y);
          } else {
            squashes.splice(i, 1);
          }
        }
      }

      function updatePowerUps() {
        const now = millis();

        if (activePowerUp && now > activeEndsAt) {
          activePowerUp = null;
          scoreMultiplier = 1;
          nextPowerUpTime = now + SPAWN_INTERVAL;
        }

        if (!spawnPowerUp && !activePowerUp && now > nextPowerUpTime) {
          spawnPowerUp = createPowerUp();
        }

        if (spawnPowerUp) {
          noStroke();
          fill(spawnPowerUp.color);
          ellipse(spawnPowerUp.x, spawnPowerUp.y, POWER_UP_RADIUS * 2);
          if (isClapping && dist(spawnPowerUp.x, spawnPowerUp.y, handX, handY) < POWER_UP_RADIUS + 10) {
            activePowerUp = spawnPowerUp;
            activeEndsAt = now + activePowerUp.duration * 1000;
            scoreMultiplier = multiplierForTier(activePowerUp.tier);
            spawnPowerUp = null;
          }
        }

        if (activePowerUp) {
          fill(0);
          textAlign(CENTER, TOP);
          textSize(16);
          text("Power-Up: " + activePowerUp.name, width / 2, 10);
        }
      }

      function createPowerUp() {
        const weights = POWER_UPS.map(p => Math.log(p.rank + 1));
        const total = weights.reduce((a, b) => a + b, 0);
        let r = random(total);
        let cumulative = 0;
        for (let i = 0; i < POWER_UPS.length; i++) {
          cumulative += weights[i];
          if (r < cumulative) {
            return { ...POWER_UPS[i], x: random(width), y: random(height) };
          }
        }
        return null;
      }

      function multiplierForTier(tier) {
        switch (tier) {
          case "Legendary":
            return 5;
          case "Epic":
            return 4;
          case "Rare":
            return 3;
          case "Uncommon":
            return 2;
          default:
            return 1.5;
        }
      }
  </script>
</body>
</html>
